# สารบัญเนื้อหาสรุป

## 1. Introduction Data Structure :bookmark_tabs: ##
## 2. Structure & Pointer :closed_book: ##
## 3. Function & Recursion :green_book: ##
## 4. Linked List :orange_book: ##
## 5. Stack :notebook: ## 
## 6. Queue :notebook_with_decorative_cover: ##
## 7. Linear & Hashing :ledger: ##
## 8. Graphs :blue_book: ##
## 9. Trees :label: ##

# Introduction Data Structure :books:

การโปรแกรมในภาษาคอมพิวเตอร์ มีสิ่งสำคัญอยู่สองอย่างคือ
1. Algorithms : ลำดับขั้นตอนในการทำงานของโปรแกรมเพื่อแก้ปัญหา
2. Data Structure : การจัดเก็บข้อมูลในหน่วยความจำ(Memory)เพื่อที่จะนำมาใช้ใน`Algorithm`ได้อย่างมีประสิทร์ภาพ

***Data Structure***
ในการจัดเก็บข้อมูลของData Structureนั้นจะเป็นการจัดเก็บข้อมูลไว้เป็นกลุ่มที่มีความเชื่อมโยงกันไว้ด้วยกัน 
จะเป็น`ข้อมูลประเภท/ โครงสร้าง`เดียวกันหรือต่างกันก็ได้ *เพื่อที่จะสะดวกในการนำมาใช้และเพื่อให้เกิดประสิทธิภาพสูงสุด*

**ประโยชน์ของData Structure ในการสร้างAlgorithms**
- นำโครงสร้างข้อมูลที่มีอยู่แล้วมาประยุกต์ใช้ในการแก้ปัญหา
- เพิ่มประสิทธิภาพในการเเขียนโปรแกรม
- สามารถนำโครงสร้างข้อมูลในรูปแบบต่างๆมาประยุกต์ใช้ให้เหมาะสมกับอัลกอริทึมนั้นๆได้อย่างเหมาะสม

## Type of Data Structure :page_with_curl:

1. Basic Data Type
   - Primtive Data Type
   - Structure Data Type
   - Pointer

2. Abstract Data Type
   - Linear Data Structure
   - Non - Linear Data Structure

## Basic Data Structure :page_with_curl:

### Primtive Data Type :pencil2:

![f8b1b4707cd00bf208706eb38997f7c2](https://user-images.githubusercontent.com/86911299/181749121-3a0aae06-ae9e-41b6-90b4-81fbf8fc2c6a.jpg)

***การแปลงเลขฐาน และการบวกลบเลขฐาน***

[ระบบเลขฐาน.pdf](https://github.com/ACHTIX/Project/files/9219516/default.pdf)

#### Binary number representation

1. Unsigned representation

ชุดข้อมูลของเลขฐานสองที่ไม่ได้กำหนดเครื่องหมาย มีทั้งหมด 0 - 256 หรือ 2^8

2. signed magnitude representation

ชุดข้อมูลที่มีเครื่องหมายสในการระบุว่าชุดข้อมูลนั้นๆเป็นบวกหรือลบ โดย`sign bit`นั้นคือตัวหน้าสุด 
ถ้าเป็น 0 = บวก  , 1 = ลบ และ`magnitude`ขนาดของบิตตัวเลขจะอยู่หลังบิตระบุเครื่องหมาย

```
0 0 0 0 0 1 1 0 = 6

1 0 0 0 0 1 1 0 = -6
```

3. 1's complement system

สามารถสลับบิตได้เลย เช่น 0 => 1 , 1 => 0

4. 2' complement system

ในการแปลงค่าให้เป็น2' complement นำค่าที่คำนวนเป็น 1' complementมาบวก1

Overflow : ข้อมูลล้นหรือข้อมูลเกิน เกิดในกรณีที่ตัวเลขที่มีขนาดใหญ่กว่าความจุของหน่วยความจำ 

Underflow : ข้อมูลน้อยเกินกว่าที่จะเก็บในหน่วยความจำจนไม่สามารถนำไปเก็บในหน่วยความจำ

Real Number : จำนวนจริงเป็นเลขทศนิยมfloating point จัดเก็บในรูปแบบเลขฐานสองแบบเดียวกับInteger 
`Normalized` การเขียนเลขฐานต่างๆ ได้ทั้งฐานสอง ฐานสิบ และอื่นๆ ให้อยู่ในรูปแบบของเลขยกกำลัง 
เช่น 1.52 x 10^15 = 152,000,000 1.1011 x 2^5 = 110110

**ในการใช้หน่วยความจำเก็บจำนวนจริง**
- Float : จะเก็บในรูปแบบ`Single precision` โดยจะใช้พื้นที่ในหน่วยความจำขนาด32บิต
- Double : จะเก็บในรูปแบบ`double precision` โดยจะใช้พื้นที่ในหน่วยความจำขนาด64บิต
ในการจัดเก็บจะแบ่งเป็น3ส่วน
1. Sign bit [s] : บิตเครื่องหมายถ้าเป็น 0 จะหมายถึงค่านั้นมีค่าบวก 1 จะหมายถึงค่านั้นมีค่าเป็นลบ 
2. Mantissa : จะใช้เก็บตัวเลขที่อยู่หลังจุดทศนิยม
3. Exponent : จะใช้เก็บตัวเลขที่เป็นเลขยกกำลัง โดยการเก็บ จะต้องนำค่ายกกำลังที่คำนวนได้ + ค่าbias(127)
 
Boolean : บูลีนเป็นข้อมูลที่มีค่าเป็นจริง`true` หรือเป็นเท็จ`false`ในภาษาซีก่อนจะใช้ต้องเรียก ` #include <stdbool.v> `
โดยค่าบูลีนส่วนใหญ่จะใช้กับ if-else statement

## Array :page_with_curl:

Array : เป็นโครงสร้างข้อมูลที่เก็บข้อมูลเป็นชุดๆในหน่วยความจำ ชนิดข้อมูลในชุดการจัดเก็บของอาเรย์จะต้องเป็นข้อมูลชนิดเดียวกัน 
และในการเข้าถึงข้อมูลจะต้องใช้การอ้างถึง`Index`ซึ่งจะเริ่มจากศูนย์ ไปถึงจำนวนn-1ของขนาดอาเรย์ทั้งหมด

### One dimensional arry :pencil2:

![images (1)](https://user-images.githubusercontent.com/86911299/181930013-96f90920-8a6d-424e-b729-46683a067db7.png)

จะจัดเก็บในลักษณะที่เป็นแถมต่อเนืองเรียงกัน ขนาดจะขึ้นอยู่กับindexของarray เช่น int num[10] = มีตำแหน่งindexตั้งแต่0 - 9
เราสามารถกำหนดค่าในแต่ละตำแหน่งได้ หรือถ้าหากไม่ได้กำหนดตัวcomplilerจะกำหนดค่า0 - 9ให้แทน

- ขอบเขตของอาร์เรย์ 1 มิติ : ช่วงขอบเขตล่างสุด(Lower Bound) [L] , ช่วงขอบเขตบนสุด(Upper Bound) [U] 
```
สูตรการคำนวนหาตำแหน่งaddressในหน่วยความจำ 
Location(Data[1]) = ตำแหน่งเริ่มต้น[ฺBase] + เนื้อที่หน่วยความจำ[w] * (ตำแหน่งที่ต้องการ[i] - ขอบเขตล่างสุด[L])
```
### Two dimensional arry :pencil2:

![อาร์เรย์สองมิติ+(Two+Dimension+Array)](https://user-images.githubusercontent.com/86911299/181931542-ec7bdc5e-bac7-472c-96e0-12f8abc6f301.jpg)

โครงสร้างข้อมูลในรูปแบบสองมิติที่จัดเก็บข้อมูลแบบตารางสองทางจะเรียงตามแนวแถว(Row) และแนวหลัก(Column)
ในการจัดเก็บสามารถทำได้สองแบบจะต้องใช้กับภาษา`ฟอร์ทราน`
R = จำนวนแถวของแถวลำดับ
i = ตำแหน่งของแถวในอาร์เรย์
j = ตำแหน่งของคอลัมน์ในอาร์เรย์

1. การจัดเก็บแบบการเรียงแถวเป็นหลัก(Row Major Order)
```
Loc(K[i , j]) = Base + w [C * (i - LR) + (j - LC)]
```

2. การจัดเก็บแบบการเรียงคอลัมน์ป็นหลัก(Column Major Order)
```
Loc(K[i , j]) = Base + w [R * (i - UR) + (j - UC)]
```

- ขอบเขตของอาร์เรย์ 2 มิติ : ช่วงขอบเขตล่างสุดของแถว(Lower Bound) [LR] , ช่วงขอบเขตบนสุดของแถว(Upper Bound) [UR]  
ช่วงขอบเขตล่างสุดของคอลัมน์(Lower Bound) [LC] , ช่วงขอบเขตบนสุดของคอลัมน์(Upper Bound) [UC]  
```
ArrayName[LR : UR : LC : UC]
สูตรการคำนวนหาตำแหน่งaddressในหน่วยความจำ 
จำนวนสมาชิก = (UR - LR + 1) * (UC - LC + 1) 
```

**การประกาศอาร์เรย์สองมิติ**
```
datatype arrayName[row size][colum size]
```

### Three dimensional arry :pencil2:

การนำอาร์เรย์สองมิติมาเรียงซ้อนกันจากที่อาร์เรย์สองมิติมีแถว(Row) คอลัมน์(Column)ในอาร์เรย์สามมิติจะมี`ความลึก(Page)`เพิ่มขึ้นมา
```
ArrayName[LR : UR : LC : UC : LP : LP]
สูตรการคำนวนหาตำแหน่งaddressในหน่วยความจำ 
จำนวนสมาชิก = (UR - LR + 1) * (UC - LC + 1) * (UP - LP + 1) 
```


**การประกาศอาร์เรย์สามมิติ**
```
datatype arrayName[row size][colum size][page size]
```


## String :page_with_curl:

String : ชุดของข้อมูลตัวอักขระ จะเก็บข้อมูลนี้ในชนิดของchar / character โดย1อักขระจะถูกเก็บใน1indexและในindexสุดท้ายจะต้องเป็น`null , \0`
แต่ถ้าหากเรากำหนดขนาดไม่พอสำหรับnull โปรแกรมจะตัดStringตัวสุดท้ายออกและนำnullมาแทน หรือจะรันในชุดข้อมูลอื่นจนกว่าจะเจอ ถึงหยุดการทำงาน

### Input & Output :pencil2:

- Input : จะใช้ฟังก์ชันในการรับค่าตัวแปรscanf() , gets()
1. scanf("%s" , variable) ในการใช้ฟังก์ชันนี้จะไม่สามารถใช้space barระหว่างการป้อนข้อมูล
2. gets(char *variable) ในการใช้ฟังก์ชันนี้จะหยุดรับข้อมูลก็ต่อเมื่อกดปุ่มenter และสามารถใช้space bar

- Output : จะใช้ฟังก์ชันในการแสดงผลลัพท์ของค่าตัวแปรที่ดำเนินการเสร็จแล้วprintf() , puts()
1. prinf("%s" , variable)
2. puts(char *varible)

### Declare String :pencil2:

สามารถประกาศและกำหนดค่าเริ่มต้นstringได้
`char variable[][] = {{"Computer"} , {"cs231"} , {"Kaset"}}`

### Function `#include <string.h>` :pencil2:

String manipulation : การประมวลผลสายอักขระสามารถนำมาใช้ในการจัดการข้อมูลอักขระได้ ทั้งการนับความยาว การเปรียบเทียบ การนำมาต่อกัน

#### strcmp()

นำสตริงสองตัวมาต่อกัน 
- var1 < var2 : ได้ผลลัพท์น้อยกว่าศูนย์ 
- var1 > var2 : ได้ผลลัพท์มากกว่าศูนย์
- var1 = var2 : ได้ผลลัพท์เท่ากัน
และผลลัพท์ที่ได้จะส่งกลับมาในรูปแบบจำนวนเต็ม

```
int strcmp(char *var1 , char *var2);
```

#### strcpy()

ฟังก์ชันนี้จะเป็นการคัดลอกข้อมูลจากสตริงนึงไปยังอีกสตริงนึก โดยตัวที่เป็นหลักต้องมีขนาดมากกว่าหรือเท่ากัน
ในการคัดลอกสตริงจะคัดลอกทีละตัวจนกว่าจะ\0ก็จะหยุดคัดลอก และไม่คัดลอก\0ไปด้วย
dest = ตัวแปรปลายทาง src = ตัวแปรต้นทาง

```
char * strcpy(char *dest , char * src);
```

#### strlen()

นับความยาวของสตริง และไม่นับ\0

```
int strlen(str);
```

#### strcat()

นำสตริงสองชุดมาเชื่อมต่อกันผลลัพท์ที่จะได้ตัวสตริงจะมีความยาวเท่ากับสตริงสองชุดมาต่อกัน
dest = ตัวแปรปลายทางที่เก็บผลลัพท์จากการเชื่อมต่อกัน src = ตัวแปรต้นทางนำสตริงไปเชื่อมต่อกัน

```
char *strcat(char *dest , char *src);
```

#### strncpy()

ฟังก์ชันนี้จะเป็นการคัดลอกข้อมูลจากสตริงนึงไปยังอีกสตริงนึง โดยตัวที่เป็นหลักต้องมีขนาดมากกว่าหรือเท่ากัน
ในการคัดลอกสตริงจะคัดลอกทีละตัวจนกว่าจะ\0ก็จะหยุดคัดลอก และไม่คัดลอก\0ไปด้วย และ`สามารถระบุความยาวที่สุด`
dest = ตัวแปรปลายทาง src = ตัวแปรต้นทาง size_t maxlen = ตัวแปรที่ระบุความยาวของสตริง

```
char * strcpy(char *dest , char * src , size_t maxlen);
```

# Structure & Pointer :books:

## Structure :page_with_curl:

### :pencil2:

## Pointer :page_with_curl:

### :pencil2:


# Function & Recursion :books:

# Linked List :books:

# Stack :books:

# Queue :books:

# Linear & Hashing :books:

# Graphs :books:

# Trees :books: