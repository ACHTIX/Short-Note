# สารบัญเนื้อหาสรุป

## 1. Introduction Data Structure :bookmark_tabs: ##
## 2. Structure & Pointer :closed_book: ##
## 3. Function & Recursion :green_book: ##
## 4. Linked List :orange_book: ##
## 5. Stack :notebook: ## 
## 6. Queue :notebook_with_decorative_cover: ##
## 7. Linear & Hashing :ledger: ##
## 8. Graphs :blue_book: ##
## 9. Trees :label: ##

# Introduction Data Structure :books:

การโปรแกรมในภาษาคอมพิวเตอร์ มีสิ่งสำคัญอยู่สองอย่างคือ
1. Algorithms : ลำดับขั้นตอนในการทำงานของโปรแกรมเพื่อแก้ปัญหา
2. Data Structure : การจัดเก็บข้อมูลในหน่วยความจำ(Memory)เพื่อที่จะนำมาใช้ใน`Algorithm`ได้อย่างมีประสิทร์ภาพ

***Data Structure***
ในการจัดเก็บข้อมูลของData Structureนั้นจะเป็นการจัดเก็บข้อมูลไว้เป็นกลุ่มที่มีความเชื่อมโยงกันไว้ด้วยกัน 
จะเป็น`ข้อมูลประเภท/ โครงสร้าง`เดียวกันหรือต่างกันก็ได้ *เพื่อที่จะสะดวกในการนำมาใช้และเพื่อให้เกิดประสิทธิภาพสูงสุด*

**ประโยชน์ของData Structure ในการสร้างAlgorithms**
- นำโครงสร้างข้อมูลที่มีอยู่แล้วมาประยุกต์ใช้ในการแก้ปัญหา
- เพิ่มประสิทธิภาพในการเเขียนโปรแกรม
- สามารถนำโครงสร้างข้อมูลในรูปแบบต่างๆมาประยุกต์ใช้ให้เหมาะสมกับอัลกอริทึมนั้นๆได้อย่างเหมาะสม

## Type of Data Structure :page_with_curl:

1. Basic Data Type
   - Primtive Data Type
   - Structure Data Type
   - Pointer

2. Abstract Data Type
   - Linear Data Structure
   - Non - Linear Data Structure

## Basic Data Structure :page_with_curl:

### Primtive Data Type :pencil2:

![f8b1b4707cd00bf208706eb38997f7c2](https://user-images.githubusercontent.com/86911299/181749121-3a0aae06-ae9e-41b6-90b4-81fbf8fc2c6a.jpg)

***การแปลงเลขฐาน และการบวกลบเลขฐาน***

[ระบบเลขฐาน.pdf](https://github.com/ACHTIX/Project/files/9219516/default.pdf)

#### Binary number representation

1. Unsigned representation

ชุดข้อมูลของเลขฐานสองที่ไม่ได้กำหนดเครื่องหมาย มีทั้งหมด 0 - 256 หรือ 2^8

2. signed magnitude representation

ชุดข้อมูลที่มีเครื่องหมายสในการระบุว่าชุดข้อมูลนั้นๆเป็นบวกหรือลบ โดย`sign bit`นั้นคือตัวหน้าสุด 
ถ้าเป็น 0 = บวก  , 1 = ลบ และ`magnitude`ขนาดของบิตตัวเลขจะอยู่หลังบิตระบุเครื่องหมาย

```
0 0 0 0 0 1 1 0 = 6

1 0 0 0 0 1 1 0 = -6
```

3. 1's complement system

สามารถสลับบิตได้เลย เช่น 0 => 1 , 1 => 0

4. 2' complement system

ในการแปลงค่าให้เป็น2' complement นำค่าที่คำนวนเป็น 1' complementมาบวก1

Overflow : ข้อมูลล้นหรือข้อมูลเกิน เกิดในกรณีที่ตัวเลขที่มีขนาดใหญ่กว่าความจุของหน่วยความจำ 

Underflow : ข้อมูลน้อยเกินกว่าที่จะเก็บในหน่วยความจำจนไม่สามารถนำไปเก็บในหน่วยความจำ

Real Number : จำนวนจริงเป็นเลขทศนิยมfloating point จัดเก็บในรูปแบบเลขฐานสองแบบเดียวกับInteger 
`Normalized` การเขียนเลขฐานต่างๆ ได้ทั้งฐานสอง ฐานสิบ และอื่นๆ ให้อยู่ในรูปแบบของเลขยกกำลัง 
เช่น 1.52 x 10^15 = 152,000,000 1.1011 x 2^5 = 110110

**ในการใช้หน่วยความจำเก็บจำนวนจริง**
- Float : จะเก็บในรูปแบบ`Single precision` โดยจะใช้พื้นที่ในหน่วยความจำขนาด32บิต
- Double : จะเก็บในรูปแบบ`double precision` โดยจะใช้พื้นที่ในหน่วยความจำขนาด64บิต
ในการจัดเก็บจะแบ่งเป็น3ส่วน
1. Sign bit [s] : บิตเครื่องหมายถ้าเป็น 0 จะหมายถึงค่านั้นมีค่าบวก 1 จะหมายถึงค่านั้นมีค่าเป็นลบ 
2. Mantissa : จะใช้เก็บตัวเลขที่อยู่หลังจุดทศนิยม
3. Exponent : จะใช้เก็บตัวเลขที่เป็นเลขยกกำลัง โดยการเก็บ จะต้องนำค่ายกกำลังที่คำนวนได้ + ค่าbias(127)
 
Boolean : บูลีนเป็นข้อมูลที่มีค่าเป็นจริง`true` หรือเป็นเท็จ`false`ในภาษาซีก่อนจะใช้ต้องเรียก ` #include <stdbool.v> `
โดยค่าบูลีนส่วนใหญ่จะใช้กับ if-else statement

## Array :page_with_curl:

Array : เป็นโครงสร้างข้อมูลที่เก็บข้อมูลเป็นชุดๆในหน่วยความจำ ชนิดข้อมูลในชุดการจัดเก็บของอาเรย์จะต้องเป็นข้อมูลชนิดเดียวกัน 
และในการเข้าถึงข้อมูลจะต้องใช้การอ้างถึง`Index`ซึ่งจะเริ่มจากศูนย์ ไปถึงจำนวนn-1ของขนาดอาเรย์ทั้งหมด

### One dimensional arry :pencil2:

![images (1)](https://user-images.githubusercontent.com/86911299/181930013-96f90920-8a6d-424e-b729-46683a067db7.png)

จะจัดเก็บในลักษณะที่เป็นแถมต่อเนืองเรียงกัน ขนาดจะขึ้นอยู่กับindexของarray เช่น int num[10] = มีตำแหน่งindexตั้งแต่0 - 9
เราสามารถกำหนดค่าในแต่ละตำแหน่งได้ หรือถ้าหากไม่ได้กำหนดตัวcomplilerจะกำหนดค่า0 - 9ให้แทน

- ขอบเขตของอาร์เรย์ 1 มิติ : ช่วงขอบเขตล่างสุด(Lower Bound) [L] , ช่วงขอบเขตบนสุด(Upper Bound) [U] 
```
สูตรการคำนวนหาตำแหน่งaddressในหน่วยความจำ 
Location(Data[1]) = ตำแหน่งเริ่มต้น[ฺBase] + เนื้อที่หน่วยความจำ[w] * (ตำแหน่งที่ต้องการ[i] - ขอบเขตล่างสุด[L])
```
### Two dimensional arry :pencil2:

![อาร์เรย์สองมิติ+(Two+Dimension+Array)](https://user-images.githubusercontent.com/86911299/181931542-ec7bdc5e-bac7-472c-96e0-12f8abc6f301.jpg)

โครงสร้างข้อมูลในรูปแบบสองมิติที่จัดเก็บข้อมูลแบบตารางสองทางจะเรียงตามแนวแถว(Row) และแนวหลัก(Column)
ในการจัดเก็บสามารถทำได้สองแบบจะต้องใช้กับภาษา`ฟอร์ทราน`
R = จำนวนแถวของแถวลำดับ
i = ตำแหน่งของแถวในอาร์เรย์
j = ตำแหน่งของคอลัมน์ในอาร์เรย์

1. การจัดเก็บแบบการเรียงแถวเป็นหลัก(Row Major Order)
```
Loc(K[i , j]) = Base + w [C * (i - LR) + (j - LC)]
```

2. การจัดเก็บแบบการเรียงคอลัมน์ป็นหลัก(Column Major Order)
```
Loc(K[i , j]) = Base + w [R * (i - UR) + (j - UC)]
```

- ขอบเขตของอาร์เรย์ 2 มิติ : ช่วงขอบเขตล่างสุดของแถว(Lower Bound) [LR] , ช่วงขอบเขตบนสุดของแถว(Upper Bound) [UR]  
ช่วงขอบเขตล่างสุดของคอลัมน์(Lower Bound) [LC] , ช่วงขอบเขตบนสุดของคอลัมน์(Upper Bound) [UC]  
```
ArrayName[LR : UR : LC : UC]
สูตรการคำนวนหาตำแหน่งaddressในหน่วยความจำ 
จำนวนสมาชิก = (UR - LR + 1) * (UC - LC + 1) 
```

**การประกาศอาร์เรย์สองมิติ**
```
datatype arrayName[row size][colum size]
```

### Three dimensional arry :pencil2:

การนำอาร์เรย์สองมิติมาเรียงซ้อนกันจากที่อาร์เรย์สองมิติมีแถว(Row) คอลัมน์(Column)ในอาร์เรย์สามมิติจะมี`ความลึก(Page)`เพิ่มขึ้นมา
```
ArrayName[LR : UR : LC : UC : LP : LP]
สูตรการคำนวนหาตำแหน่งaddressในหน่วยความจำ 
จำนวนสมาชิก = (UR - LR + 1) * (UC - LC + 1) * (UP - LP + 1) 
```


**การประกาศอาร์เรย์สามมิติ**
```
datatype arrayName[row size][colum size][page size]
```


## String :page_with_curl:

String : ชุดของข้อมูลตัวอักขระ จะเก็บข้อมูลนี้ในชนิดของchar / character โดย1อักขระจะถูกเก็บใน1indexและในindexสุดท้ายจะต้องเป็น`null , \0`
แต่ถ้าหากเรากำหนดขนาดไม่พอสำหรับnull โปรแกรมจะตัดStringตัวสุดท้ายออกและนำnullมาแทน หรือจะรันในชุดข้อมูลอื่นจนกว่าจะเจอ ถึงหยุดการทำงาน

### Input & Output :pencil2:

- Input : จะใช้ฟังก์ชันในการรับค่าตัวแปรscanf() , gets()
1. scanf("%s" , variable) ในการใช้ฟังก์ชันนี้จะไม่สามารถใช้space barระหว่างการป้อนข้อมูล
2. gets(char *variable) ในการใช้ฟังก์ชันนี้จะหยุดรับข้อมูลก็ต่อเมื่อกดปุ่มenter และสามารถใช้space bar

- Output : จะใช้ฟังก์ชันในการแสดงผลลัพท์ของค่าตัวแปรที่ดำเนินการเสร็จแล้วprintf() , puts()
1. prinf("%s" , variable)
2. puts(char *varible)

### Declare String :pencil2:

สามารถประกาศและกำหนดค่าเริ่มต้นstringได้
`char variable[][] = {{"Computer"} , {"cs231"} , {"Kaset"}}`

### Function `#include <string.h>` :pencil2:

String manipulation : การประมวลผลสายอักขระสามารถนำมาใช้ในการจัดการข้อมูลอักขระได้ ทั้งการนับความยาว การเปรียบเทียบ การนำมาต่อกัน

#### strcmp()

นำสตริงสองตัวมาต่อกัน 
- var1 < var2 : ได้ผลลัพท์น้อยกว่าศูนย์ 
- var1 > var2 : ได้ผลลัพท์มากกว่าศูนย์
- var1 = var2 : ได้ผลลัพท์เท่ากัน
และผลลัพท์ที่ได้จะส่งกลับมาในรูปแบบจำนวนเต็ม

```
int strcmp(char *var1 , char *var2);
```

#### strcpy()

ฟังก์ชันนี้จะเป็นการคัดลอกข้อมูลจากสตริงนึงไปยังอีกสตริงนึก โดยตัวที่เป็นหลักต้องมีขนาดมากกว่าหรือเท่ากัน
ในการคัดลอกสตริงจะคัดลอกทีละตัวจนกว่าจะ\0ก็จะหยุดคัดลอก และไม่คัดลอก\0ไปด้วย
dest = ตัวแปรปลายทาง src = ตัวแปรต้นทาง

```
char * strcpy(char *dest , char * src);
```

#### strlen()

นับความยาวของสตริง และไม่นับ\0

```
int strlen(str);
```

#### strcat()

นำสตริงสองชุดมาเชื่อมต่อกันผลลัพท์ที่จะได้ตัวสตริงจะมีความยาวเท่ากับสตริงสองชุดมาต่อกัน
dest = ตัวแปรปลายทางที่เก็บผลลัพท์จากการเชื่อมต่อกัน src = ตัวแปรต้นทางนำสตริงไปเชื่อมต่อกัน

```
char *strcat(char *dest , char *src);
```

#### strncpy()

ฟังก์ชันนี้จะเป็นการคัดลอกข้อมูลจากสตริงนึงไปยังอีกสตริงนึง โดยตัวที่เป็นหลักต้องมีขนาดมากกว่าหรือเท่ากัน
ในการคัดลอกสตริงจะคัดลอกทีละตัวจนกว่าจะ\0ก็จะหยุดคัดลอก และไม่คัดลอก\0ไปด้วย และ`สามารถระบุความยาวที่สุด`
dest = ตัวแปรปลายทาง src = ตัวแปรต้นทาง size_t maxlen = ตัวแปรที่ระบุความยาวของสตริง

```
char * strcpy(char *dest , char * src , size_t maxlen);
```

# Structure & Pointer :books:

## Structure :page_with_curl:

โครงสร้างข้อมูลแบบstructure การกำหนดข้อมูลชนิดใหม่ขึ้นมา โดยจะรวมชนิดข้อมูลพื้นฐานไว้ จะเป็นข้อมูลชนิดเดียวกันหรือต่างชนิดกันก้ได้
แต่ในชุดข้อมูลต้องมีความเชือมโยงกันหรือเกี่ยวข้องกัน และในโครงสร้างข้อมูลแบบstructureจะมี
`record / struct`จะเก็บข้อมูลต่างกันในชุดโครงสร้างเดียวกัน เช่น ในโครงสร้างข้อมูลที่เก็บข้อมูลรายชื่อรหัสของนิสิต
record จะเก็บเป็นรายบุคคล หลายๆบุคคลรวมกัน

![296620498_732730577832963_5535013250790364011_n](https://user-images.githubusercontent.com/86911299/182015142-3af3ae68-2714-4f00-bfd7-ff7a7f676e2f.jpg)

### การกำหนดตัวแปรชนิดโครงสร้าง :pencil2:

```
struct struct_name{
   type field1;
   type field2;
   .
   .
   .
   type fieldn;
};
```


ในการกำหนดค่าให้กับตัวแปรต่างๆในโครงสร้างข้อมูลที่กำหนด

```
struct struct_name field;
```

หรือจะกำหนดตัวแปรไปพร้อมกับการกำหนดโครงสร้างข้อมูลเลยก็ได้

```
struct struct_name{
   type field1;
   type field2;
   .
   .
   .
   type fieldn;
}field_name;
```

ในการกำหนดค่าในตัวแปรชนิดโครงสร้างข้อมูลโดยใช้เครื่องหมาย[.]

```
ชื่อตัวแปรงโครงสร้าง.ชื่อสมาชิกในโครงสร้าง;
```

### input & output :pencil2:

- ในการรับinputหรือการกำหนดค่าชนิดข้อมูลอื่นๆที่ไม่ใช่stringจะสามารถใช้เครื่องหมาย[=]
- การรับinputเป็นStringจะไม่สามารถกำหนดค่าโดยใช้เครื่องหมาย[=]จะต้องใช้ฟังก์ชัน`strcpy() , gets() , scanf()`
- ในการแสดงผลของoutput สำหรับในภาษาซีจะสามารถใช้`printf()`

### Array + Structure :pencil2:

![296228690_457215412939774_8479325969192878050_n](https://user-images.githubusercontent.com/86911299/182020162-b96a0a95-5fa0-4ef7-916f-479fcd76ec62.jpg)

ในการนำโครงสร้างข้อมูลแบบStructureมาใช้กับarrayจะทำให้ข้อมูลในรูปบบสตริงหรือข้อความรายบุคคลใช้งานได้สะดวกและง่ายดายมากขึั้น
ในชุดข้อมูลนั้นๆจำเป็นต้องมีความเกี่ยวข้องและเชื่อมโยงกันด้วย

```
struct struct_name{
   type field1;
   type field2;
   .
   .
   .
   type fieldn;
}field_name;

struct struct_name[];
```
![295931890_1159458858260109_3350104657265853866_n](https://user-images.githubusercontent.com/86911299/182020267-d40b5001-e848-420c-9a86-2edb1c698442.jpg)

### Nest Structure :pencil2:

โครงสร้างซ้อนโครงสร้าง เหมือนการจัดเก็บโครงสร้างข้อมูลย่อยไว้ในโครงสร้างข้อมูลกล่องใหญ่ๆ

![296088847_600511421432714_1120103785893153271_n](https://user-images.githubusercontent.com/86911299/182020362-5796b5b9-ff60-4e25-a4ea-4e9988e86f81.jpg)

## Pointer :page_with_curl:

Pointer : เป็นชนิดข้อมูลที่มีความเร็วในการทำงานสูง ทำให้การเขียนภาษาซีมีความยืดหยุ่น 
แต่การที่จะใช้ชนิดข้อมูลพอยเตอร์จะมีความซับซ้อนค่อนข้างสูง แต่ก็ทำให้การใช้ข้อมูลชนิดพอยเตอร์เป็นจุดเด่นในภาษาซี

### Declaration Pointer :pencil2:

ในการประกาศตัวแปรพอยเตอร์เราจะกำหนดชื่อตัวแปรใช้แทนข้อมูลและจองพื้นที่ในการอ้างอิงถึงตัวแปร
สามารถกำหนดชนิดของตัวแปรพอยเตอร์เป็นตัวชี้ไปยังตัวแปรชนิดอื่นๆได้

**ในการจองพื้นที่ต้อง`address`ส่วนใหญ่จะถูกเก็บเป็นเลขฐาน16เพราะข้อมูลมีขนาดยาวมาก**

```
type *variable_name;

int i; จะจองพื้นทั้งหมด4 byteตามชนิดของตัวแปรint และใช้ชื่อตัวแปรiเพื่ออ้างอิงถึงตัวแปร
int *p; ตัวแปรประเภทพอยเตอร์ จะใช้เครื่องหมาย[*]
i = 10; ตัวกำหนดค่าให้ตัวแปรi
p = &i; pเป็นตัวแปรที่เก็บaddress จะใช้เครื่องหมาย[&]
```

### การแสดงค่าAddress :pencil2:

ในการแสดงค่าaddress จะใช้ฟังก์ชันprintfโดยใช้`%p , %u`
%p = แสดงตำแหน่งของaddressที่เป็นเลขฐาน16
%u = แสดงตำแหน่งของaddressที่เป็นเลขฐาน10

### Pointerซ้อนPointer :pencil2:

ในการประกาศพอยเตอร์ซ้อนพอยเตอร์จะใช้เครื่องหมาย[*]สองตัวซ้อนกันเพื่อแสดงถึงพอยเตอร์ซ้อนพอยเตอร์

```
type **variable_name;
```

### Pointer Vs. Array :pencil2:

ในการใช้ตัวแปรชนิดพอยเตอร์สามารถใช้ควบคู่ไปกับตัวแปรชนิดอาร์เรย์ได้ โดยกำหนดตัวแปรคล้ายๆกับการประกาศทั่วไป
เพียงแต่เราสามารถเรียกค่าaddressของindexในarrayได้ เช่น varptr = &a[0]; ตัวแปรvarptr = จะเก็บค่าaddressของตัวแปรa ตำแหน่งที่0

**การบวกลบจำนวนเต็มกับพอยเตอร์**
- ค่าของพอยเตอร์จะไม่เพิ่มหรือลดลงตามตัวเลขจำนวนนั้น
- ค่าของaddressจะเพิ่มหรือลดลงตามมจำนวนนั้นคูณกับขนาดของตัวแปรที่ถูกชี้อยู่

```
int v[5];
int *vPtr;
vPtr += 2; => vPtr = vPtr + (2 * 4) 
```
2 = จะขึ้นอยู่กับการเขียนโปรแกรม 
4 = ขนาดของตัวแปร 

## Pointer Vs. Structure :page_with_curl:

เราสามารถใช้งานสมาชิกของตัวแปรได้สองวิธี
1. ใช้เครื่องหมาย[.]ในการเข้าถึงข้อมูล`struct_name.field_name`
2. ใช้เครื่องหมาย[->]ในการเข้าถึงข้อมูล ในกรณีที่ตัวแปรเป็นพอยเตอร์ไปปยังตัวแปรของโครงสร้าง`pointer_name->field_name`

## การกำหนดประเภทข้อมูลที่ผู้ใช้กำหนดเอง :page_with_curl:

`typedef` การนิยามประเภทของข้อมูล เราสามารถประกาศตัวแปรในรูปแบบของประเภทข้อมูลด้วยคำใหม่ได้
โดยคำที่นิยามใหม่จะใช้แทนชนิดข้อมูลต่างๆเช่น int float double

```
typedef type new_type;
```

# Function & Recursion :books:

## Function :page_with_curl:

Function : ฟังก์ชันคือชุดคำสั่งในการทำงาน จะสามารถเรียกใช้ได้ง่าย และผู้ใช้ไม่จำเป็นต้องรู้รายละเอียดของระบบการทำงานทั้งหมดก็ได้
เพียงแค่รู้วิธีการใช้งานและผลลัพธ์ก็ได้ สำหรับฟังก์ชันสามารถเขียนให้โปรแกรมมีการทำงานที่ซับซ้อนได้ แบ่งเป็นสองประเภท

- Standard library function : ฟังก์ชันไลบรารีมาตรฐานจะสามารถเรียกใช้โดยคำ `#include <directives>`
Directives แทนกลุ่มของฟังก์ชันในแต่ละแบบ เช่น stdio.h , conio.h , string.h math.h และฟังก์ชันมาตรจะมีการทำงานในรูปแบบเฉพาะงานพื้นฐานจึงทำให้ต้องสร้างรูปแบบเฉพาะขึ้นมา

- User Defined function : ในการทำงานรูปแบบเฉพาะทางจะต้องสร้างขึ้นมาเอง 
โดยมีข้อกำหนดการเขียน 
1. สร้างฟังก์ชันก่อนที่จะสร้างmain
2. สร้างmainก่อนที่จะสร้างฟังก์ชัน จึงต้องใช้การประกาศ`function prototype`

![296036084_1224997751610870_8499602511448098384_n](https://user-images.githubusercontent.com/86911299/182026084-4c9a5dce-5c7a-475b-9a8e-5c7720a1d34f.jpg)

### function prototype :pencil2:
```
type function_name(type1, type2, ... ,typen);
```

![295666468_750512639548786_9030175358266972520_n](https://user-images.githubusercontent.com/86911299/182026217-5b623cc7-f0f8-44c1-9f89-f7a84c2e1625.jpg)
![295684891_366139085668058_4540643205752000105_n](https://user-images.githubusercontent.com/86911299/182026219-4fe1670f-ed93-443d-a41e-b9809ad271a6.jpg)
![296243188_448037197199260_8719984754030229176_n](https://user-images.githubusercontent.com/86911299/182026220-cac8ba57-f730-40f4-abdf-c6773e7d0925.jpg)
![296575014_487901123144684_443353130266227159_n](https://user-images.githubusercontent.com/86911299/182026224-04391ab8-2dfb-4722-bf36-44f7fc78164c.jpg)

### Global :pencil2:

ตัวแปรที่ฟังก์ชันใดก็สามารถเรียกใช้ได้โดยการประกาศตัวแปรต่อจาก`preprocessor directive` ใช้ได้ทั้งในmainและฟังก์ชันที่ประกาศ

### Local :pencil2:

ตัวแปรที่สามารถใช้ได้เฉพาะภายในฟังก์ชันที่ประกาศตัวแปรนั้นๆ

### Pass by value :pencil2:

ส่งค่าเข้ามาในฟังก์ชัน โปรแกรมมันประกาศตัวแปรใหม่ แล้วก็ copy ค่ากำหนดให้กับมันเฉยๆเท่านั้น

### Pass by reference :pencil2:

เปลี่ยนค่าในฟังก์ชันแล้วตัวแปรจริงๆก็เปลี่ยนค่าตาม จะมีการนำpointerเข้ามาใช้ด้วย 
เพราะ pointerเหมือนการร่างไว้ก่อน สามารถแก้ไขค่าของตัวแปรที่มันชี้อยู่ได้โดยใช้ค่าที่เคยร่างไว้แล้ว

## Recursion :page_with_curl:


# Linked List :books:

# Stack :books:

# Queue :books:

# Linear & Hashing :books:

# Graphs :books:

# Trees :books: